# Decision Tree: Bandwidth Optimization Strategy
# Helps identify and fix high bandwidth usage
# Version: 1.0.0

id: "bandwidth-optimization"
title: "Bandwidth Optimization Strategy"
description: "Diagnose bandwidth issues and apply Netcode 2.7.0 optimizations"
category: "performance"
difficulty: "intermediate"
estimated_time: 10

start_node: "measure-baseline"

nodes:
  - id: "measure-baseline"
    type: "action"
    content: "First, measure your current bandwidth usage"
    action:
      type: "guide"
      steps:
        - "Open Network Traffic Analyzer (when available) or Unity Profiler"
        - "Run game with typical player count"
        - "Note bandwidth per player (KB/s)"
        - "Identify top 3 bandwidth consumers"
      tool: "NetworkTrafficAnalyzer or Unity Profiler → Networking"
    next: "baseline-check"

  - id: "baseline-check"
    type: "question"
    content: "What is your current bandwidth per player?"
    options:
      - label: ">500 KB/s (HIGH - needs optimization)"
        next: "high-bandwidth-diagnosis"
      - label: "200-500 KB/s (MEDIUM - room for improvement)"
        next: "medium-bandwidth-diagnosis"
      - label: "<200 KB/s (LOW - already optimized!)"
        next: "already-optimized"

  - id: "already-optimized"
    type: "outcome"
    outcome:
      recommendation: "Your bandwidth is already excellent!"
      explanation: |
        <200 KB/s per player is very good for multiplayer games.
        Focus on maintaining this with code reviews and monitoring.
      best_practices:
        - "Use Network Traffic Analyzer to catch regressions"
        - "Set up automated bandwidth tests in CI"
        - "Document your optimization patterns for team"

  - id: "high-bandwidth-diagnosis"
    type: "question"
    content: "What is consuming the most bandwidth?"
    help: "Check Unity Profiler or Traffic Analyzer"
    options:
      - label: "NetworkVariables updating too frequently"
        next: "optimize-network-variables"
      - label: "Too many RPC calls"
        next: "optimize-rpcs"
      - label: "Large data in messages (strings, arrays)"
        next: "optimize-data-size"
      - label: "Syncing objects that are far away"
        next: "use-relevance"

  - id: "medium-bandwidth-diagnosis"
    type: "question"
    content: "Have you implemented Netcode 2.7.0 optimizations?"
    options:
      - label: "Yes, already using batching/relevance/pooling"
        next: "advanced-optimization"
      - label: "No, haven't applied Netcode 2.7.0 features"
        next: "apply-netcode-optimizations"

  - id: "optimize-network-variables"
    type: "question"
    content: "Are you updating multiple related NetworkVariables?"
    options:
      - label: "Yes, updating health/mana/stamina separately"
        next: "use-batching"
      - label: "No, single NetworkVariable per component"
        next: "reduce-update-frequency"

  - id: "use-batching"
    type: "outcome"
    outcome:
      recommendation: "Enable NetworkVariable Batching (Netcode 2.7.0)"
      explanation: |
        Batching reduces messages by 86%!
        Combine related values into a single struct.
      
      bandwidth_savings: "86% fewer messages!"
      implementation_time: "30 minutes"
      
      code_example: |
        // BEFORE: 3 separate NetworkVariables (3 messages)
        NetworkVariable<float> health;
        NetworkVariable<float> mana;
        NetworkVariable<float> stamina;
        
        // AFTER: 1 batched NetworkVariable (1 message)
        public struct StatsBatch : INetworkSerializable {
            public float health, mana, stamina;
            // ... serialization code
        }
        NetworkVariable<StatsBatch> stats;
      
      references:
        - file: "Assets/Plugins/GameCreator_Multiplayer/Runtime/Components/NetworkStatsSync.cs"
        - file: "claudedocs/NETCODE_2_7_0_MIGRATION_GUIDE.md"
          section: "NetworkVariable Batching"
      
      next_steps:
        - "Implement struct for related values"
        - "Measure bandwidth before/after"
        - "Expected: 60-80% reduction"

  - id: "reduce-update-frequency"
    type: "outcome"
    outcome:
      recommendation: "Reduce NetworkVariable update frequency"
      explanation: |
        Only update when value actually changes.
        Use dirty flags and thresholds.
      
      code_example: |
        // BEFORE: Update every frame
        void Update() {
            m_Position.Value = transform.position; // Every frame!
        }
        
        // AFTER: Only update when changed significantly
        private Vector3 lastPosition;
        private const float THRESHOLD = 0.1f;
        
        void Update() {
            float distance = Vector3.Distance(transform.position, lastPosition);
            if (distance > THRESHOLD) {
                m_Position.Value = transform.position;
                lastPosition = transform.position;
            }
        }
      
      bandwidth_savings: "50-70% reduction"

  - id: "optimize-rpcs"
    type: "question"
    content: "Can you batch multiple RPC calls together?"
    options:
      - label: "Yes, sending multiple RPCs at once"
        next: "use-rpc-batching"
      - label: "No, but RPCs are very frequent (>10/sec)"
        next: "use-unreliable-rpcs"

  - id: "use-rpc-batching"
    type: "outcome"
    outcome:
      recommendation: "Use NetworkRPCBatcher (Netcode 2.7.0)"
      explanation: |
        Batch multiple RPCs into single network packet.
        40-60% overhead reduction!
      
      bandwidth_savings: "40-60% overhead reduction"
      
      code_example: |
        // Register handler
        int damageRpcId = NetworkRPCBatcher.Instance.RegisterRPCHandler("Damage", 
            (rpc) => ApplyDamage(rpc.floatData1));
        
        // Queue RPCs (batched automatically)
        var rpc = NetworkRPCBatcher.CreateRPC(damageRpcId);
        rpc.floatData1 = 25f;
        NetworkRPCBatcher.Instance.QueueForServer(rpc);
        
        // Flushes automatically after 10ms or 20 RPCs
      
      references:
        - file: "Assets/Plugins/GameCreator_Multiplayer/Runtime/RPC/NetworkRPCBatcher.cs"
        - file: "claudedocs/NETCODE_2_7_0_MIGRATION_GUIDE.md"
          section: "RPC Batching"

  - id: "use-unreliable-rpcs"
    type: "outcome"
    outcome:
      recommendation: "Use Unreliable RPC delivery"
      explanation: |
        For high-frequency non-critical RPCs, use unreliable delivery.
        No acknowledgment = huge bandwidth savings.
      
      bandwidth_savings: "60% reduction for high-frequency RPCs"
      
      code_example: |
        // BEFORE: Reliable (default)
        [ClientRpc]
        void UpdateEffectClientRpc(Vector3 pos) { }
        
        // AFTER: Unreliable
        [ClientRpc(Delivery = RpcDelivery.Unreliable)]
        void UpdateEffectClientRpc(Vector3 pos) { }
      
      best_for:
        - "Cosmetic effects"
        - "Position updates"
        - "Animation triggers"
      
      avoid_for:
        - "Health/damage"
        - "Inventory changes"
        - "Game state"

  - id: "optimize-data-size"
    type: "outcome"
    outcome:
      recommendation: "Optimize data serialization"
      explanation: |
        Reduce size of data sent over network.
      
      optimizations:
        strings:
          problem: "string takes 2 bytes per character"
          solution: "Use FixedString32Bytes (32 bytes max)"
          savings: "50-80% for short strings"
        
        floats:
          problem: "float is 4 bytes, often too precise"
          solution: "Use quantization (store as ushort)"
          savings: "50% (4 bytes → 2 bytes)"
        
        vectors:
          problem: "Vector3 is 12 bytes (3 floats)"
          solution: "Quantize to shorts (6 bytes)"
          savings: "50%"
      
      code_example: |
        // BEFORE: string (unlimited size)
        public string playerName;
        
        // AFTER: FixedString32Bytes (32 bytes max)
        public FixedString32Bytes playerName;
        
        // BEFORE: full precision float
        public float health; // 4 bytes
        
        // AFTER: quantized ushort
        public ushort healthQuantized; // 2 bytes
        // health = healthQuantized / 10.0f; (1 decimal place)

  - id: "use-relevance"
    type: "outcome"
    outcome:
      recommendation: "Enable Network Relevance System (Netcode 2.7.0)"
      explanation: |
        Only sync objects that are relevant to each player.
        Distance-based culling saves 30-50% bandwidth!
      
      bandwidth_savings: "30-50% reduction"
      
      setup:
        - "Add NetworkRelevance component to scene"
        - "Register NetworkObjects for relevance management"
        - "Configure distance ranges"
      
      code_example: |
        // Register object for relevance
        NetworkRelevance.Instance.RegisterObject(npcNetworkObject);
        
        // Important objects always sync
        NetworkRelevance.Instance.SetAlwaysSync(playerNetworkObject, true);
        
        // Configure ranges in Inspector:
        // Close: 0-20m (30 Hz)
        // Medium: 20-50m (10 Hz)
        // Far: 50-100m (2 Hz)
        // Culled: >100m (0 Hz)
      
      references:
        - file: "Assets/Plugins/GameCreator_Multiplayer/Runtime/Optimization/NetworkRelevance.cs"
        - file: "claudedocs/NETCODE_2_7_0_MIGRATION_GUIDE.md"
          section: "Relevance System"
      
      bandwidth_savings_breakdown:
        - "Culled objects: 100% saved"
        - "Far objects: 93% saved (30Hz → 2Hz)"
        - "Medium objects: 67% saved (30Hz → 10Hz)"

  - id: "apply-netcode-optimizations"
    type: "outcome"
    outcome:
      recommendation: "Implement All Netcode 2.7.0 Optimizations"
      explanation: |
        You haven't applied the Netcode 2.7.0 improvements yet!
        These are production-ready and provide massive gains.
      
      total_bandwidth_savings: "55-65%!"
      
      priority_order:
        1:
          feature: "Network Relevance"
          savings: "30-50%"
          time: "30 minutes"
          complexity: "Low"
        
        2:
          feature: "NetworkVariable Batching"
          savings: "20-30%"
          time: "1 hour"
          complexity: "Medium"
        
        3:
          feature: "RPC Batching"
          savings: "10-15%"
          time: "1 hour"
          complexity: "Medium"
      
      references:
        - file: "claudedocs/NETCODE_2_7_0_MIGRATION_GUIDE.md"
        - file: "claudedocs/NETCODE_2_7_0_COMPLETE.md"

  - id: "advanced-optimization"
    type: "outcome"
    outcome:
      recommendation: "Advanced Optimizations"
      explanation: |
        You've applied basic optimizations.
        Here are advanced techniques:
      
      techniques:
        delta_compression:
          description: "Only send changed fields"
          savings: "20-40%"
          complexity: "High"
        
        interest_management:
          description: "Players only see what's in their view"
          savings: "40-60%"
          complexity: "High"
        
        lod_networking:
          description: "Reduce update rate for distant objects"
          savings: "30-50%"
          complexity: "Medium"
          note: "Network Relevance does this automatically"
      
      code_example: |
        // Delta compression example
        public struct PlayerState {
            public byte dirtyFlags; // Which fields changed
            public Vector3 position; // Only send if bit 0 set
            public float health;     // Only send if bit 1 set
            // ...
        }

